Windows下安装Django

首先要安装python,2.4+,我使用的是python 2.6
从Django官网下载最新安装包：https://www.djangoproject.com/download/
我下载的是Django-1.3.1.tar.gz.解压到目录E:\python_source\Django\src,我是使用Netbeans建立的项目文件夹。

python setup.py install 

安装完成后在python命令行下
>>>import django
>>>django.VERSION
会打印出
(1, 3, 1, 'final', 0)

但是使用idle打开会提示找不到django模块。因为django模块并没有像一些文档描述的那样安装到python的安装目录\Lib\site-packages下，于是按The django book2.0推荐安装svn版本的方法，在
python的安装目录\Lib\site-packages下新建django.pth,向里面写入django解压时的目录，即E:\python_source\Django\src，保存后重启idle,执行以下命令。sys.path已经把django的安装路径加入进来了。

>>> import django
>>> import sys
>>> print sys.path
['C:\\Python26\\Lib\\idlelib', 'C:\\WINDOWS\\system32\\python26.zip', 'C:\\Python26\\DLLs', 'C:\\Python26\\lib', 'C:\\Python26\\lib\\plat-win', 'C:\\Python26\\lib\\lib-tk', 'C:\\Python26', 'C:\\Python26\\lib\\site-packages', 'E:\\python_source\\Django\\src']
>>> django.VERSION
(1, 3, 1, 'final', 0)

-------------------------------------------
知道昨天出问题的原因，也就是为什么django没有安装到python安装目录下的Lib/site-packages下。

因为之前装了cywin,一个在windows下模拟linux环境的工具，相当于虚拟机，里面也是装有python解析器的并且优先于Windows下的python解析器，于是在调用python setup.py install 时，如果没错的话，实际上是安装到了cywin下python的site-packages,由于用命令行调用的仍然是cywin下的python,用Idle则是使用win下的python，所以就是出现两者在寻找django模块路径上的问题。

解决的方法，把python的安装目录加入path,并且放在cywin的c:/cywind/win前。这样，系统调用的才是win下的python解析器。

-------------------------------------------
运行命令django-admin.py startproject mysite。这样会在你的当前目录下创建一个目录。mysite

以下命令启动开发服务器
python manage.py runserver
python manage.py runserver 8080
python manage.py runserver 0.0.0.0:8000
-------------------------------------------
assert False 可以用在任意处触发异常取得Django的调试信息
输出信息详细，比print好用
-------------------------------------------
如果命令行或idle下调用template模块报
DJANGO_SETTINGS_MODULE 未定义

>>> from django.template import Template
>>> t = Template('my name is {{name}}')

在系统环境变量定义环境变量
 项目设置模块
即项目自动生成的settings.py文件

DJANGO_SETTINGS_MODULE 为 mysite.settings

或者使用
python manage.py shell 启动交互界面。
-------------------------------------------
>>> from django.template import Template
>>> t = Template('my name is {{name}}')
>>> from django.template import Context
>>> c = Context({'name':'Falcon'})
>>> print t.render(c)
my name is Falcon
>>> 
-------------------------------------------
这就是使用Django模板系统的基本规则： 写模板，创建 Template 对象，创建 Context ， 调用 render() 方法。

-------------------------------------------
使用同一模板源渲染多个context
>>> names = ('King','Falcon','Raw')
>>> for name in names:
	print t.render(Context({'name':name}))

	
my name is King
my name is Falcon
my name is Raw
>>> 
-------------------------------------------
在模板中可以通过句点访问对像的属性或者字典值
-------------------------------------------
点语法也可以用来引用对象的* 方法*。 例如，每个 Python 字符串都有 upper() 和 isdigit() 方法，你在模板中可以使用同样的句点语法来调用它们：

>>> from django.template import Template, Context
>>> t = Template('{{ var }} -- {{ var.upper }} -- {{ var.isdigit }}')
>>> t.render(Context({'var': 'hello'}))
u'hello -- HELLO -- False'
>>> t.render(Context({'var': '123'}))
u'123 -- 123 -- True'

注意这里调用方法时并* 没有* 使用圆括号 而且也无法给该方法传递参数；你只能调用不需参数的方法。 
-------------------------------------------
句点也可用于访问列表索引，例如：

>>> from django.template import Template, Context
>>> t = Template('Item 2 is {{ items.2 }}.')
>>> c = Context({'items': ['apples', 'bananas', 'carrots']})
>>> t.render(c)
u'Item 2 is carrots.'

不允许使用负数列表索引。 像 {{ items.-1 }} 这样的模板变量将会引发`` TemplateSyntaxError``
-------------------------------------------
>>> t2 = Template('Item 2 is {{items.2}}')
>>> c2 = Context({'items':['x','y','z']})
>>> t2.render(c2)
u'Item 2 is z'
>>> class Person:
	def __init__(self):
		self.name = 'falcon'
		self.age = '333'

		
>>> t3 = Template('Info \n name:{{person.name}} | age:{{person.age}}')
>>> c3 = Context({'person':Person()})
>>> t3.render(c3)
u'Info \n name:falcon | age:333'
>>> 
-------------------------------------------
Exception里定义silent_variable_failure 属性为 True 时，不会传播异常

>>> class SilentAssertionError(AssertionError):
...     silent_variable_failure = True
>>> class PersonClass4:
...     def first_name(self):
...         raise SilentAssertionError
>>> p = PersonClass4()
>>> t.render(Context({"person": p}))
u'My name is .'
-------------------------------------------
假如accout类有这样一个方法
def delete(self):
    # Delete the account
delete.alters_data = True #该方法的alter_data属性为真，则载入模板时并不会执行delete方法，会静默错误退出
-------------------------------------------
默认情况下，如果一个变量不存在，模板系统会把它展示为空字符串，不做任何事情来表示失败
-------------------------------------------
{% if %}标签不允许在同一个标签内同时使用and 和or,但可以多次使用同一个逻辑操作符如and 或or ,不支持圆括号组合比较操作。可以考虑移到模板外处理或仅仅用嵌套的{% if %} 标签替换

{% if athlete_list %}
    {% if coach_list or cheerleader_list %}
        We have athletes, and either coaches or cheerleaders!
    {% endif %}
{% endif %}

-------------------------------------------
没有{% elif %} 标签
-------------------------------------------
给标签增加一个 reversed 使得该列表被反向迭代：

{% for athlete in athlete_list reversed %}
...
{% endfor %}
-------------------------------------------
for 支持一个可选的{% empty %}分句，
可以定义当列表为空时的输出内容

{% for student in students %}
  <p>{{student.name}}</p>
{% empty %}
  <p>"no student in list"</p>
{% endfor %}
-------------------------------------------
注释
{# This is a comment #}
{% comment %}
..line1
..line2
{% endcomment %}
-------------------------------------------
过滤器
{{name|lower}}

-------------------------------------------
后台运行测试服务器并且不输出访问信息
./manage.py runserver 1>/dev/null 2>&1 &
-------------------------------------------

模板继承和重载 (block标签和extends)
基础模板base.html
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html lang="en">
<head>
    <title>{% block title %}{% endblock %}</title>
</head>
<body>
    <h1>My helpful timestamp site</h1>
    {% block content %}{% endblock %}
    {% block footer %}
    <hr>
    <p>Thanks for visiting my site.</p>
    {% endblock %}
</body>
</html>

子模板1 
{% extends "base.html" %}

{% block title %}The current time{% endblock %}

{% block content %}
<p>It is now {{ current_date }}.</p>
{% endblock %}

子模板2
{% extends "base.html" %}

{% block title %}Future time{% endblock %}

{% block content %}
<p>In {{ hour_offset }} hour(s), it will be {{ next_time }}.</p>
{% endblock %}

注意由于子模板并没有定义 footer 块，模板系统将使用在父模板中定义的值。 父模板 {% block %} 标签中的内容总是被当作一条退路。
-------------------------------------------
Django 对MVC的解释

Django 紧紧地遵循这种 MVC 模式，可以称得上是一种 MVC 框架。 以下是 Django 中 M、V 和 C 各自的含义：

    M ，数据存取部分，由django数据库层处理，本章要讲述的内容。

    V ，选择显示哪些数据要显示以及怎样显示的部分，由视图和模板处理。

    C ，根据用户输入委派视图的部分，由 Django 框架根据 URLconf 设置，对给定 URL 调用适当的 Python 函数。
-------------------------------------------
MTV 

由于 C 由框架自行处理，而 Django 里更关注的是模型（Model）、模板(Template)和视图（Views），Django 也被称为 MTV 框架 。在 MTV 开发模式中：

    M 代表模型（Model），即数据存取层。 该层处理与数据相关的所有事务： 如何存取、如何验证有效性、包含哪些行为以及数据之间的关系等。

    T 代表模板(Template)，即表现层。 该层处理与表现相关的决定： 如何在页面或其他类型文档中进行显示。

    V 代表视图（View），即业务逻辑层。 该层包含存取模型及调取恰当模板的相关逻辑。 你可以把它看作模型与模板之间的桥梁。

-------------------------------------------
Django 

Django 对 MVC 的诠释中，视图用来描述要展现给用户的数据；不是数据 如何展现 ,而且展现 哪些 数据。 相比之下，Ruby on Rails 及一些同类框架提倡控制器负责决定向用户展现哪些数据，而视图则仅决定 如何 展现数据，而不是展现 哪些 数据。
-------------------------------------------

