策略模式：

定义算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
封装变化

多用组合，少用继承

针对接口编程，不针对实现编程

------------------------------------------------------------------------------


观察者模式：

在对象之间定义了一对多的依赖，这样一来，当一个对象改变状时，依赖他的对象也会发到通知并自动更新。


努力做到松耦合！因为松耦合更具弹性，更能适应变化。

------------------------------------------------------------------------------
貌似在PHP里面，一个方法在父类中声明不抽象，在子类中声明为抽象，会出错的。
但是Java是支持的

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

------------------------------------------------------------------------------


装饰者模式 ：费解。。。。

类应该对扩展开放而对修改关闭。
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

除了继承，装饰者模式也可以让我们扩展行为。

装饰者模式意味着一群装饰者类，这些类用来包装具体组件

装饰者反映出被装饰的组件的类型，事实上，他们具有相同的类型，都经过接口或继承实现。

装饰者对组件的客户是透明的，除非客户程序依赖于组件的具体类型

装饰者会导致设计中出现许多小对象，如果过度使用，会让程序变得很复杂。

------------------------------------------------------------------------------
工厂模式



///我的理解：独立出来专门创建对象的一个类或者抽象方法。一定程度上实现解耦


///无论属性是什么对象，只要知道它的接口类型，就能根据接口的属性和方法编程。

//所有工厂模式都用来封装对象的创建，工厂方法通过让子类决定创建的对象是什么。来达到将子类的创建过程封装的目的。
------------------------------------------------------------------------------
工厂方法模式
定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个，工厂方法让类把实例化推迟到子类。

以下为工厂方法的：

abstract class PizzaStore {

//这个不变化 可以用final 禁止子类改写
	final public function orederPizza ($type) {
//这样无论什么类型的Pizza都按照这个流程，与类型无关，解耦，不需要知道实际创建的对象是哪一个。
		$pizza = $this->createPizza($type);
		$pizza->prepare();
		$pizza->bake();
		$pizza->cut();
		$pizza->box();
		return $pizza;
	}

	//把这个方法抽象了，把实例化推迟到子类。
	abstract function createPizza($type);
}

------------------------------------------------------------------------------
要依赖抽象，不要依赖具体类！
------------------------------------------------------------------------------
依赖倒置原则。

///从底层具体类抽象出接口。在高层对接口编程,因此不用理会具体类

指导方针：
1.变量不可以持有具体类的引用
2.不要让类派生自具体类
3.不要覆盖基类中已实现的方法。

///晕，这些指导方针全被我违反过……
///往下再读，发现原则是死的，人是活的，具体问题具体分析
///对于不像是会改变的类，实例化具体类是没问题的。
///对于可能改变的类，就要用一些方法（如工厂）封装变化。
------------------------------------------------------------------------------



