没有程序语言是完美的，甚至没有一个唯一最好的语言，只有对于特定目的，比较适合和不适合的程序语言。

dotcloud:python
服务名:falcon.www
http://falcon-falconpython.dotcloud.com/


[root@falconHost ~]:#dotcloud alias add falcon.www py.onephper.tk
Ok. Now please add the following DNS record:
py.onephper.tk. IN CNAME gateway.dotcloud.com.

DNSpod：wonderfulcxm@gmail.com

Push
[root@falconHost dotcloud]:#dotcloud push falcon python_on_dotcloud/

-------------------------------------------

dotcloud:php+mysql
服务名gophp.www

===========================================

-------------------------------------------
suid,guid
suid文件属性首位设置为4
guid文件属性首位设置为2
同时设置时文件属性首位设置为6

如chmod 4755 <filename> 结果:rwsr-xr-x 文件被设置为suid，执行时具有属主权限，完成该权限消失

或者这样设置chmod u+s <filename>

-------------------------------------------
chown/chgrp -R -h owner file
-R 递归目录文件
-h 改变链接文件属主时不影响该链接所指向的目标文件
-------------------------------------------
group 取得自己所属用户组。
一个用户可以从属多个用户组。
group <username> 取得某个用户所在的用户组
(group在centos 5.7上不可用，不过可以查看/etc/group文件)
或者使用id命令:
# id
或者 # id <username>
-------------------------------------------
umask 确定创建文件的缺省模式。与 chmod命令相反。
对于文件，刚创建时不具有执行权限，所以最大为6
如果umask为022，那么刚创建文件为644,创建目录为755


-------------------------------------------
find命令 后面接的-exec或-ok(以询问的方式执行)
 find . -name "info.txt" -exec ls -l {} \;
 find . -name 'admin.log[0-9][0-9[0-9]' -ok rm {} \;
支持正则?
-------------------------------------------
find 配合xargs
使用xargs时能够批量取得参数以及每一次取得参数的数目都会根据该命令选项和内核中相应的可调参数来确定。
-------------------------------------------
使用grep命令在当前目录所有普通文件中搜索php这个词
find . -name * -type f -print | xargs grep "php"
如果仅显示其文件名
find . -name * -type f -print | xargs echo ""
-------------------------------------------
cron和crontab
crontab格式
分 时 日 月 星期 要运行的命令
crontab [-u username] -e -l -r
-e 编辑crontab文件
-l 列出crontab文件的内容
-r 删除crontab文件
-------------------------------------------

如
30 21 * * * /apps/bin/clear.sh
0,30 18-23 * * * /apps/bin/dbcheck.sh
每天18-23点之间每三十分钟运行一次
-------------------------------------------
提交crontab
创建一个davecron文件 
写入
50,51,52, 18 * * * /bin/echo `date` >/dev/console
使用#注释cron脚本
$ crontab davecron
新建的文件副本会放置在/var/spool/cron目录内，文件名为对应的用户名
-------------------------------------------
at命令
通过 /etc/at.allow和/etc/at.deny限制
at [-f script] [-m -l -r] [time] [date]
其中 -f script 是所要提交的脚本或命令
-m 完成作业后发邮件给用户
-l 列出当前等待运行的作业
-r 清除作业，需提供相应的作业id

#echo find /etc -name "passwd" -print | at now + 1 minute
等同
#at now + 1 minute
at>find /etc -name "passwd" -print
at><EOT>

-------------------------------------------
&
将命令后台运行并把结果输出到文件（标准输出和错误输出）
# command >out.file 2>&1 &
用&提交的命令在帐户退出时进程会结束，如果想要退出帐户之后继续运行，可以使用nohup命令
#nohup command &
-------------------------------------------
用cat在命令行写入文件
#cat > test
输入文字
<CTRL-D>

-------------------------------------------

echo -n 输出不换行
echo -e 转义字符串
-------------------------------------------

read 
取得用户输入并赋值给指定变量
# read name 
# echo $name
如果输入变量比指定的变量数要多（用空格分隔），则剩余字符会被赋值给最后一个变量。
-------------------------------------------
echo "please input a number:\c" && read number && echo $number
-------------------------------------------
cat -v <file_name>可以显示文件的所有控制字符
-------------------------------------------
tee -a 显示并把副本追加到文件末
#echo "hello end" | tee -a log.txt
-------------------------------------------
标准输入 0
标准输出 1
标准错误 2

把标准输出和标准错误一起重定向到file
command 1>file 2>&1
把file1作为标准输入，把标准输出重定向到file2
command <file1 >file2
-------------------------------------------
创建一个长度为0的空文件
$ >myfile

$ sort <name.txt

$ sort <name.txt >name.out

$ mail root < content.txt

-------------------------------------------
sort排序
-------------------------------------------
exec
-------------------------------------------
脚本
#!/bin/env bash
exec 4<&0 0</root/info.txt
read line1
read line2
read line3
exec 0<&4
echo $line1
echo $line2
echo $line3

-------------------------------------------
&& 前一个命令执行成功才执行后一个命令
|| 前一个命令执行失败才执行后一条命令
在当前shell中执行一组命令
(命令1;命令2;...)
使用在子shell而不是当前shell中作为一个整体执行
{命令1;命令2;...}
-------------------------------------------
grep
在输出字符串参数时，最好将其用双引号括起来，调用变量时也应该使用双引号，在调用模式匹配时，应该使用单引号

如 #grep "$MYVAR" 文件名
#grep '^[^48]' data.f 抽出行首不是48的记录
#grep '4\{2,\}' data.f 数字4至少出现两次的所有行
#grep '0\{2,\}' passwd 

-c 只输出匹配行的计数
-i 不区分大小写(只适合单字符)
-h 查询多文件时不显示文件名
-l 仅输出包含匹配字符的文件名
-n 显示匹配行及行号
-s 不显示不存在或无匹配文本的错误信息
-v 显示不包含匹配文本的所有行

-E参数允许使用扩展模式匹配
$grep -E '219|216' data.f
-------------------------------------------

egrep
#cat grepstrings
484
47
#egrep -f grepstrings data.file //按文件提供的模式匹配

#egrep '(abc|xyz)' data.file //查找符号两边或全部
-------------------------------------------
awk
===========================================

[root@falconHost ~]# awk -F: 'BEGIN {print "name\thome\n---------"} {print $1"\t"$6} END {print "\n--EOF"}' /etc/passwd


双引号：awk 'BEGIN{print "\""}'
这里使用""是因为awk里面打印常量都要用""括起来，\是转义，免得前两个双引号配对，产生错误。
单 引号：awk 'BEGIN{print "'\''"}'
这里其实可以这样理解awk 'BEGIN{print "'       \'              '"}'
注意配对方式，先打印BEGIN{print "，然后是\'，然后是"}，因为\'被bash解析成'，所以awk得到的是BEGIN{print "'"}

BEGIN{print "'"}，为什么要用双引号括起来，前面说过了。
如 果你使用文件(awk -f)，那么还会简单一点：
14:38:18#www#test> cat a.awk
#!/usr/bin/awk -f
BEGIN{print "'"}
14:38:23#www#test> awk -f a.awk
'
14:38:26#www#test>
因为bash不会转义文件里面的东西，所以就不用\和里面那层''了。
-------------------------------------------

#awk -F: '{print $1"'\'s\ home\ is\ '"$6}' testfile 

root's home is /root
bin's home is /bin
daemon's home is /sbin
adm's home is /var/adm
lp's home is /var/spool/lpd
sync's home is /sbin
shutdown's home is /sbin
halt's home is /sbin
mail's home is /var/spool/mail
news's home is /etc/news
uucp's home is /var/spool/uucp
...
...
或者
awk -F: '{print $1"\047s home is "$6}' testfile 
-------------------------------------------
正则表达式
[root@falconHost ~]# awk '{if($2~/^g/) print $0}' testfile2
12 games /usr/games
13 gopher /var/gopher
42 gdm /var/gdm
504 gearmand /home/gearmand
-------------------------------------------
统计CSDN邮箱
[root@falconHost ~]# awk -F " # " '{if($3~/@qq\.com/) print $0}' csdn.sql |wc -l
1909819
[root@falconHost ~]# awk -F " # " '{if($3~/@[126\.com|163\.com|netease\.com]/) print $0}' csdn.sql |wc -l
3456342
[root@falconHost ~]# awk -F " # " '{if($3~/@gmail\.com/) print $0}' csdn.sql |wc -l
185140

否定
-------------------------------------------

awk常量

ARGC 命令行参数个数
ARGV 命令行参数排列
ENVIRON 支持队列中系统环境变量的使用
FILENAME awk浏览的文件名
FNR 浏览文件的记录数
FS 设置输入域分隔符，等价于命令行-F选项
NF 浏览记录的域个数
NR 已读的记录数
OFS 输出域分隔符
ORS 输出记录分隔符
RS 控制记录分隔符
-------------------------------------------
[root@falconHost ~]# awk -F " # " '{print NF,NR,$0} END{print FILENAME}' csdn.sql |head -10
3 1 zdg # 12344321 # zdg@csdn.net
3 2 LaoZheng # 670203313747 # chengming_zheng@163.com
3 3 fstao # 730413 # fstao@tom.com
3 4 huwolf # 2535263 # hujiye@263.net
3 5 cadcjl # KIC43dk6! # ccedcjl@21cn.com
3 6 netsky # s12345 # songmail@21cn.com
3 7 Michael # apple # appollp@netease.com
3 8 siclj # lj7202 # junlu@peoplemail.com.cn
3 9 jinbuhuan # 12345 # jinbuhuan@163.net
3 10 Eie # hebeibdh # fwg@jxfw.com

-------------------------------------------
[root@falconHost ~]# awk -F " # " '{if(NR<=10 || NF!=3) print NF,NR,$0}' csdn.sql 
3 1 zdg # 12344321 # zdg@csdn.net
3 2 LaoZheng # 670203313747 # chengming_zheng@163.com
3 3 fstao # 730413 # fstao@tom.com
3 4 huwolf # 2535263 # hujiye@263.net
3 5 cadcjl # KIC43dk6! # ccedcjl@21cn.com
3 6 netsky # s12345 # songmail@21cn.com
3 7 Michael # apple # appollp@netease.com
3 8 siclj # lj7202 # junlu@peoplemail.com.cn
3 9 jinbuhuan # 12345 # jinbuhuan@163.net
3 10 Eie # hebeibdh # fwg@jxfw.com
-------------------------------------------
取当前路径所在目录
[root@falconHost init.d]# echo $PWD
/etc/rc.d/init.d
[root@falconHost init.d]# echo $PWD | awk -F/ '{print $NF}'
init.d

因为NF表示域数目，$NF即为最后一个成员
-------------------------------------------
密码与用户名相同的用户
[root@falconHost ~]# awk -F" # " '{name=$1;password=$2;email=$3; if(name==password) print NR":" name "->" password}' csdn.sql |wc -l
292661
-------------------------------------------
密码名与用户名相同且都为数字

[root@falconHost ~]# awk -F" # " '{name=$1;password=$2;email=$3; if(name==password && name~/^[0-9]+$/) print NR":" name "->" password}' csdn.sql 

-------------------------------------------
取记录总行数
[root@falconHost ~]# wc -l csdn.sql | awk '{print $1}'
6428631

------------------------------------------
通常在BEGIN部分赋值是很有益的，方便以后修改
-------------------------------------------
[root@falconHost ~]:#awk -F' # ' '{if($1=="Zboy") ($1="xman");  if(NR>90) print NR ,$1}' testfile 

[root@falconHost ~]:#awk -F" # " '{print substr($3,1,index($3,"@")-1)}' testfile

-------------------------------------------
awk传参：

[root@falconHost ~]:#who | awk '{if($1==usr) print $1 " connect to "$2}' usr=$LOGNAME

-------------------------------------------
计算当前文件夹的总文件大小 
[root@falconHost ~]:#ll | awk '($1~/^[^d]/) {tot+=$5} END {print "file total size:" tot}'
file total size:287242130
-------------------------------------------

df -lh -查看硬盘使用率

du -lh查看文件夹使用空间 ，指定目录的层数 --max-depth=

-------------------------------------------
C:\Documents and Settings\Administrator\VirtualBox VMs\Centos64\Centos64.vdi
-------------------------------------------



