没有程序语言是完美的，甚至没有一个唯一最好的语言，只有对于特定目的，比较适合和不适合的程序语言。

dotcloud:python
服务名:falcon.www
http://falcon-falconpython.dotcloud.com/


[root@falconHost ~]:#dotcloud alias add falcon.www py.onephper.tk
Ok. Now please add the following DNS record:
py.onephper.tk. IN CNAME gateway.dotcloud.com.

DNSpod：wonderfulcxm@gmail.com

Push
[root@falconHost dotcloud]:#dotcloud push falcon python_on_dotcloud/

-------------------------------------------

dotcloud:php+mysql
服务名gophp.www

===========================================

-------------------------------------------
suid,guid
suid文件属性首位设置为4
guid文件属性首位设置为2
同时设置时文件属性首位设置为6

如chmod 4755 <filename> 结果:rwsr-xr-x 文件被设置为suid，执行时具有属主权限，完成该权限消失

或者这样设置chmod u+s <filename>

-------------------------------------------
chown/chgrp -R -h owner file
-R 递归目录文件
-h 改变链接文件属主时不影响该链接所指向的目标文件
-------------------------------------------
group 取得自己所属用户组。
一个用户可以从属多个用户组。
group <username> 取得某个用户所在的用户组
(group在centos 5.7上不可用，不过可以查看/etc/group文件)
或者使用id命令:
# id
或者 # id <username>
-------------------------------------------
umask 确定创建文件的缺省模式。与 chmod命令相反。
对于文件，刚创建时不具有执行权限，所以最大为6
如果umask为022，那么刚创建文件为644,创建目录为755


-------------------------------------------
find命令 后面接的-exec或-ok(以询问的方式执行)
 find . -name "info.txt" -exec ls -l {} \;
 find . -name 'admin.log[0-9][0-9[0-9]' -ok rm {} \;

取反写在查询路径后
 find . ! -name 'admin.log[0-9][0-9[0-9]' -ok rm {} \;
支持正则?
-------------------------------------------
find 配合xargs
使用xargs时能够批量取得参数以及每一次取得参数的数目都会根据该命令选项和内核中相应的可调参数来确定。
-------------------------------------------
删除所有比quote.txt新的文件
[root@falconHost ~]:#find . -newer quote.txt -type f -ok rm -rf {} \;
< rm ... ./xxx > ? y
-------------------------------------------
使用grep命令在当前目录所有普通文件中搜索php这个词
find . -name * -type f -print | xargs grep "php"
如果仅显示其文件名
find . -name * -type f -print | xargs echo ""
-------------------------------------------
cron和crontab
crontab格式
分 时 日 月 星期 要运行的命令
crontab [-u username] -e -l -r
-e 编辑crontab文件
-l 列出crontab文件的内容
-r 删除crontab文件
-------------------------------------------

如
30 21 * * * /apps/bin/clear.sh
0,30 18-23 * * * /apps/bin/dbcheck.sh
每天18-23点之间每三十分钟运行一次
-------------------------------------------
提交crontab
创建一个davecron文件 
写入
50,51,52, 18 * * * /bin/echo `date` >/dev/console
使用#注释cron脚本
$ crontab davecron
新建的文件副本会放置在/var/spool/cron目录内，文件名为对应的用户名
-------------------------------------------
at命令
通过 /etc/at.allow和/etc/at.deny限制
at [-f script] [-m -l -r] [time] [date]
其中 -f script 是所要提交的脚本或命令
-m 完成作业后发邮件给用户
-l 列出当前等待运行的作业
-r 清除作业，需提供相应的作业id

#echo find /etc -name "passwd" -print | at now + 1 minute
等同
#at now + 1 minute
at>find /etc -name "passwd" -print
at><EOT>

-------------------------------------------
&
将命令后台运行并把结果输出到文件（标准输出和错误输出）
# command >out.file 2>&1 &
用&提交的命令在帐户退出时进程会结束，如果想要退出帐户之后继续运行，可以使用nohup命令
#nohup command &
-------------------------------------------
用cat在命令行写入文件
#cat > test
输入文字
<CTRL-D>

-------------------------------------------

echo -n 输出不换行
echo -e 转义字符串
-------------------------------------------

read 
取得用户输入并赋值给指定变量
# read name 
# echo $name
如果输入变量比指定的变量数要多（用空格分隔），则剩余字符会被赋值给最后一个变量。
-------------------------------------------
echo "please input a number:\c" && read number && echo $number
-------------------------------------------
cat -v <file_name>可以显示文件的所有控制字符
-------------------------------------------
tee -a 显示并把副本追加到文件末
#echo "hello end" | tee -a log.txt
-------------------------------------------
标准输入 0
标准输出 1
标准错误 2

把标准输出和标准错误一起重定向到file
command 1>file 2>&1
把file1作为标准输入，把标准输出重定向到file2
command <file1 >file2
-------------------------------------------
创建一个长度为0的空文件
$ >myfile

$ sort <name.txt

$ sort <name.txt >name.out

$ mail root < content.txt

-------------------------------------------
sort排序
-------------------------------------------
exec
-------------------------------------------
脚本
#!/bin/env bash
exec 4<&0 0</root/info.txt
read line1
read line2
read line3
exec 0<&4
echo $line1
echo $line2
echo $line3

-------------------------------------------
&& 前一个命令执行成功才执行后一个命令
|| 前一个命令执行失败才执行后一条命令
在当前shell中执行一组命令
(命令1;命令2;...)
使用在子shell而不是当前shell中作为一个整体执行
{命令1;命令2;...}
-------------------------------------------
grep
在输出字符串参数时，最好将其用双引号括起来，调用变量时也应该使用双引号，在调用模式匹配时，应该使用单引号

如 #grep "$MYVAR" 文件名
#grep '^[^48]' data.f 抽出行首不是48的记录
#grep '4\{2,\}' data.f 数字4至少出现两次的所有行
#grep '0\{2,\}' passwd 

-c 只输出匹配行的计数
-i 不区分大小写(只适合单字符)
-h 查询多文件时不显示文件名
-l 仅输出包含匹配字符的文件名
-n 显示匹配行及行号
-s 不显示不存在或无匹配文本的错误信息
-v 显示不包含匹配文本的所有行

-E参数允许使用扩展模式匹配
$grep -E '219|216' data.f
-------------------------------------------

egrep
#cat grepstrings
484
47
#egrep -f grepstrings data.file //按文件提供的模式匹配

#egrep '(abc|xyz)' data.file //查找符号两边或全部
-------------------------------------------
awk
===========================================

[root@falconHost ~]# awk -F: 'BEGIN {print "name\thome\n---------"} {print $1"\t"$6} END {print "\n--EOF"}' /etc/passwd


双引号：awk 'BEGIN{print "\""}'
这里使用""是因为awk里面打印常量都要用""括起来，\是转义，免得前两个双引号配对，产生错误。
单 引号：awk 'BEGIN{print "'\''"}'
这里其实可以这样理解awk 'BEGIN{print "'       \'              '"}'
注意配对方式，先打印BEGIN{print "，然后是\'，然后是"}，因为\'被bash解析成'，所以awk得到的是BEGIN{print "'"}

BEGIN{print "'"}，为什么要用双引号括起来，前面说过了。
如 果你使用文件(awk -f)，那么还会简单一点：
14:38:18#www#test> cat a.awk
#!/usr/bin/awk -f
BEGIN{print "'"}
14:38:23#www#test> awk -f a.awk
'
14:38:26#www#test>
因为bash不会转义文件里面的东西，所以就不用\和里面那层''了。
-------------------------------------------

#awk -F: '{print $1"'\'s\ home\ is\ '"$6}' testfile 

root's home is /root
bin's home is /bin
daemon's home is /sbin
adm's home is /var/adm
lp's home is /var/spool/lpd
sync's home is /sbin
shutdown's home is /sbin
halt's home is /sbin
mail's home is /var/spool/mail
news's home is /etc/news
uucp's home is /var/spool/uucp
...
...
或者
awk -F: '{print $1"\047s home is "$6}' testfile 
-------------------------------------------
正则表达式
[root@falconHost ~]# awk '{if($2~/^g/) print $0}' testfile2
12 games /usr/games
13 gopher /var/gopher
42 gdm /var/gdm
504 gearmand /home/gearmand
-------------------------------------------
统计CSDN邮箱
[root@falconHost ~]# awk -F " # " '{if($3~/@qq\.com/) print $0}' csdn.sql |wc -l
1909819
[root@falconHost ~]# awk -F " # " '{if($3~/@[126\.com|163\.com|netease\.com]/) print $0}' csdn.sql |wc -l
3456342
[root@falconHost ~]# awk -F " # " '{if($3~/@gmail\.com/) print $0}' csdn.sql |wc -l
185140

否定
-------------------------------------------

awk常量

ARGC 命令行参数个数
ARGV 命令行参数排列
ENVIRON 支持队列中系统环境变量的使用
FILENAME awk浏览的文件名
FNR 浏览文件的记录数
FS 设置输入域分隔符，等价于命令行-F选项
NF 浏览记录的域个数
NR 已读的记录数
OFS 输出域分隔符
ORS 输出记录分隔符
RS 控制记录分隔符
-------------------------------------------
[root@falconHost ~]# awk -F " # " '{print NF,NR,$0} END{print FILENAME}' csdn.sql |head -10
3 1 zdg # 12344321 # zdg@csdn.net
3 2 LaoZheng # 670203313747 # chengming_zheng@163.com
3 3 fstao # 730413 # fstao@tom.com
3 4 huwolf # 2535263 # hujiye@263.net
3 5 cadcjl # KIC43dk6! # ccedcjl@21cn.com
3 6 netsky # s12345 # songmail@21cn.com
3 7 Michael # apple # appollp@netease.com
3 8 siclj # lj7202 # junlu@peoplemail.com.cn
3 9 jinbuhuan # 12345 # jinbuhuan@163.net
3 10 Eie # hebeibdh # fwg@jxfw.com

-------------------------------------------
[root@falconHost ~]# awk -F " # " '{if(NR<=10 || NF!=3) print NF,NR,$0}' csdn.sql 
3 1 zdg # 12344321 # zdg@csdn.net
3 2 LaoZheng # 670203313747 # chengming_zheng@163.com
3 3 fstao # 730413 # fstao@tom.com
3 4 huwolf # 2535263 # hujiye@263.net
3 5 cadcjl # KIC43dk6! # ccedcjl@21cn.com
3 6 netsky # s12345 # songmail@21cn.com
3 7 Michael # apple # appollp@netease.com
3 8 siclj # lj7202 # junlu@peoplemail.com.cn
3 9 jinbuhuan # 12345 # jinbuhuan@163.net
3 10 Eie # hebeibdh # fwg@jxfw.com
-------------------------------------------
取当前路径所在目录
[root@falconHost init.d]# echo $PWD
/etc/rc.d/init.d
[root@falconHost init.d]# echo $PWD | awk -F/ '{print $NF}'
init.d

因为NF表示域数目，$NF即为最后一个成员
-------------------------------------------
密码与用户名相同的用户
[root@falconHost ~]# awk -F" # " '{name=$1;password=$2;email=$3; if(name==password) print NR":" name "->" password}' csdn.sql |wc -l
292661
-------------------------------------------
密码名与用户名相同且都为数字

[root@falconHost ~]# awk -F" # " '{name=$1;password=$2;email=$3; if(name==password && name~/^[0-9]+$/) print NR":" name "->" password}' csdn.sql 

-------------------------------------------
取记录总行数
[root@falconHost ~]# wc -l csdn.sql | awk '{print $1}'
6428631

------------------------------------------
通常在BEGIN部分赋值是很有益的，方便以后修改
-------------------------------------------
[root@falconHost ~]:#awk -F' # ' '{if($1=="Zboy") ($1="xman");  if(NR>90) print NR ,$1}' testfile 

[root@falconHost ~]:#awk -F" # " '{print substr($3,1,index($3,"@")-1)}' testfile

-------------------------------------------
awk传参：

[root@falconHost ~]:#who | awk '{if($1==usr) print $1 " connect to "$2}' usr=$LOGNAME

-------------------------------------------
计算当前文件夹的总文件大小 
[root@falconHost ~]:#ll | awk '($1~/^[^d]/) {tot+=$5} END {print "file total size:" tot}'
file total size:287242130
-------------------------------------------

df -lh -查看硬盘使用率

du -lh查看文件夹使用空间 ，指定目录的层数 --max-depth=

-------------------------------------------
C:\Documents and Settings\Administrator\VirtualBox VMs\Centos64\Centos64.vdi
-------------------------------------------
sed
-------------------------------------------
x x为一行号，如1
x , y 表示行号范围从x到y，如2，5表示从第2行到第
/ p a t t e r n / 查询包含模式的行。例如/ d i s k /或/[a-z]/ 
/ p a t t e r n / p a t t e r n / 查询包含两个模式的行。例如/ d i s k / d i s k s /
p a t t e r n / , x 在给定行号上查询包含模式的行。如/ r i b b o n / , 3
x , / p a t t e r n / 通过行号和模式查询匹配行。3 . / v d u /
x , y ! 查询不包含指定行号x和y的行。1 , 2 !
-------------------------------------------
编辑命令
p 打印匹配行
= 显示文件行号
a \ 在定位行号后附加新文本信息
i \ 在定位行号后插入新文本信息
d 删除定位行
c \ 用新文本替换定位文本
s 使用替换模式替换相应模式
r 从另一个文件中读文本
w 写文本到一个文件
q 第一个模式匹配完成后推出或立即推出
l 显示与八进制A S C I I代码等价的控制字符
{ } 在定位行执行的命令组
n 从另一个文件中读文本下一行，并附加在下一行
g 将模式2粘贴到/pattern n/
y 传送字符
n 延续到下一输入行；允许跨行的模式匹配语句
-------------------------------------------
例子：
===========================================
quote.txt
-------------------------------------------
The honeysuckle band played all night long for only $90.
It was an evening of splendid music and company.
Too bad the disco floor fell thrugh at 23:10.
The local nurse Misss P.Neave was in attendance.
===========================================

按行号打印特定行
[root@falconHost ~]:#sed -n '1,3p' quote.txt 
The honeysuckle band played all night long for only $90.
It was an evening of splendid music and company.
Too bad the disco floor fell thrugh at 23:10.
[root@falconHost ~]:#sed -n '2p' quote.txt 
It was an evening of splendid music and company.

按匹配模式打印行
[root@falconHost ~]:#sed -n '/Neave/'p quote.txt 
The local nurse Misss P.Neave was in attendance.
[root@falconHost ~]:#sed -n '/The/'p quote.txt 
The honeysuckle band played all night long for only $90.
The local nurse Misss P.Neave was in attendance.

模式与行号混合
[root@falconHost ~]:#sed -n '4,/The/'p quote.txt 
The local nurse Misss P.Neave was in attendance.

匹配元字符
[root@falconHost ~]:#sed -n '/\$/'p quote.txt 
The honeysuckle band played all night long for only $90.

显示整个文件
[root@falconHost ~]:#sed -n '1,$'p quote.txt 
The honeysuckle band played all night long for only $90.
It was an evening of splendid music and company.
Too bad the disco floor fell thrugh at 23:10.
The local nurse Misss P.Neave was in attendance.

任意字符
[root@falconHost ~]:#sed -n '/.*ing/'p quote.txt 
It was an evening of splendid music and company.

首行
#sed -n '1'p quote.txt
末行
#sed -n '$'p quote.txt
打印非空行
[root@falconHost ~]:#sed -n '/^$/!p' quote.txt
The honeysuckle band played all night long for only $90.
It was an evening of splendid music and company.
Too bad the disco floor fell thrugh at 23:10.
The local nurse Misss P.Neave was in attendance.

打印行号
#sed -e '/music/=' quote.txt 
( -e 和模式后面加= )会把整个文件和匹配行号打印出来，
[root@falconHost ~]:#sed -n '/music/=' quote.txt
2
-------------------------------------------
Linux sed命令实例详解
功能说明：利用script来处理文本文件。

语　　法：sed [-hnV][-e<script>][-f<script文件>][文本文件]

补充说明：sed可依照script的指令，来处理、编辑文本文件。

参　　数：
-e<script>或―expression=<script>   以选项中指定的script来处理输入的文本文件。
-f<script文件>或―file=<script文件>   以选项中指定的script文件来处理输入的文本文件。
-h或―help 显示帮助。
-n或―quiet或--silent 仅显示script处理后的结果。
-V或―version 显示版本信息。

# sed -e 's/123/1234/' a.txt
将a.txt文件中所有行中的123用1234替换（-e表示命令以命令行的方式执行；参数s，表示执行替换操作）
# sed -e '3,5 a4' a.txt
将a.txt文件中的3行到5行之间所有行的后面添加一行内容为4的行（参数a，表示添加行，参数a后面指定添加的内容）
# sed -e '1 s/12/45/' a.txt
把第一行的12替换成45
sed -i "s/oldstring/newstring/g" `grep oldstring -rl yourdir`
批量处理通过grep搜索出来的所有文档，将这些文档中所有的oldstring用newstring替换（-i参数表示直接对目标文件操作）
$ sed -n 's/^test/mytest/p' example.file
(-n)选项和p标志一起使用表示只打印那些发生替换的行。也就是说，如果某一行开头的test被替换成mytest，就打印它。(^这是正则表达式中表示开头，该符号后面跟的就是开头的字符串)（参数p表示打印行）
$ sed 's/^wangpan/&19850715/' example.file
表示被替换换字符串被找到后，被替换的字符串通过＆符号连接给出的字符串组成新字符传替换被替换的字符串,所有以wangpan开头的行都会被替换成它自已加19850715，变成wangpan19850715
$ sed -n 's/\(love\)able/\1rs/p' example.file
love被标记为1，所有loveable会被替换成lovers，而且替换的行会被打印出来。需要将这条命令分解，s/是表示替换操作，\(love\)表示选中love字符串，\(love\)able/表示包含loveable的行，\(love\)able/\l表示love字符串标记为1，表示在替换过程中不变。rs/表示替换的目标字符串。这条命令的操作含义：只打印替换了的行
$ sed 's#10#100#g' example.file
不论什么字符，紧跟着s命令的都被认为是新的分隔符，所以，“#”在这里是分隔符，代替了默认的“/”分隔符。表示把所有10替换成100。
$ sed -n '/love/,/unlove/p' example.file
只打印包含love字符串行到包含unlove字符串行之间的所有行（确定行的范围就是通过逗号实现的）
$ sed -n '5,/^wang/p' example
只打印从第五行开始到第一个包含以wang开始的行之间的所有行
$ sed '/love/,/unlove/s/$/wangpan/' example.file
对于包含love字符串的行到包含unlove字符串之间的行，每行的末尾用字符串wangpan替换。
字符串$/表示以字符串结尾的行，$/表示每一行的结尾，s/$/wangpan/表示每一行的结尾添加wangpan字符串
$ sed -e '11,53d' -e 's/wang/pan/' example.file
(-e)选项允许在同一行里执行多条命令。如例子所示，第一条命令删除11至53行，第二条命令用pan替换wang。命令的执行顺序对结果有影响。如果两个命令都是替换命令，那么第一个替换命令将影响第二个替换命令的结果。(参数d，表示删除指定的行)
$ sed --expression='s/wang/pan/' --expression='/love/d' example.file
一个比-e更好的命令是--expression。它能给sed表达式赋值。
$ sed '/wangpan/r file' example.file
file里的内容被读进来，显示在与wangpan匹配的行后面，如果匹配多行，则file的内容将显示在所有匹配行的下面。参数r，表示读出文件，后面空格紧跟文件名称
$ sed -n '/test/w file' example.file
在example.file中所有包含test的行都被写入file里。参数w，表示将匹配的行写入到指定的文件file中
$ sed '/^test/a\oh! My god!' example.file
'oh! My god!'被追加到以test开头的行的后面，sed要求参数a后面有一个反斜杠。
$ sed '/test/i\oh! My god!' example.file
'oh! My god!'被追加到包含test字符串行的前面，参数i表示添加指定内容到匹配行的前面，sed要求参数i后面有一个反斜杠
$ sed '/test/{ n; s/aa/bb/; }' example.file
如果test被匹配，则移动到匹配行的下一行，替换这一行的aa，变为bb。参数n，表示读取匹配行的下一个输入行，用下一个命令处理新的行而不是匹配行。Sed要求参数n后跟分号
$ sed '1,10y/abcde/ABCDE/' example.file
把1―10行内所有abcde转变为大写，注意，正则表达式元字符不能使用这个命令。参数y，表示把一个字符翻译为另外的字符（但是不用于正则表达式）
$ sed -i 's/now/right now/g' test_sed_command.txt
表示直接操作文件test_sed_command.txt，将文件test_sed_command.txt中所有的now用right now替换。参数-i，表示直接操作修改文件，不输出。
$ sed '2q' test_sed_command.txt

在打印完第2行后，就直接退出sed。参数q，表示退出
$ sed -e '/old/h' -e '/girl-friend/G' test_sed_command.txt
首先了解参数h，拷贝匹配成功行的内容到内存中的缓冲区。在了解参数G，获得内存缓冲区的内容，并追加到当前模板块文本的后面。上面命令行的含义：将包含old字符串的行的内容保存在缓冲区中，然后将缓冲区的内容拿出来添加到包含girl-friend字符串行的后面。隐含要求搜集到缓冲区的匹配行在需要添加行的前面。
$ sed -e '/test/h' -e '/wangpan/x' example.file
将包含test字符串的行的内容保存在缓冲区中，然后再将缓冲区的内容替换包含wangpan字符串的行。参数x，表示行替换操作。隐含要求搜集到缓冲区的匹配行在需要被替换行的前面。

-------------------------------------------


