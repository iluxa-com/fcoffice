没有程序语言是完美的，甚至没有一个唯一最好的语言，只有对于特定目的，比较适合和不适合的程序语言。

-------------------------------------------
suid,guid
suid文件属性首位设置为4
guid文件属性首位设置为2
同时设置时文件属性首位设置为6

如chmod 4755 <filename> 结果:rwsr-xr-x 文件被设置为suid，执行时具有属主权限，完成该权限消失

或者这样设置chmod u+s <filename>

-------------------------------------------
chown/chgrp -R -h owner file
-R 递归目录文件
-h 改变链接文件属主时不影响该链接所指向的目标文件
-------------------------------------------
group 取得自己所属用户组。
一个用户可以从属多个用户组。
group <username> 取得某个用户所在的用户组
(group在centos 5.7上不可用，不过可以查看/etc/group文件)
或者使用id命令:
# id
或者 # id <username>
-------------------------------------------
umask 确定创建文件的缺省模式。与 chmod命令相反。
对于文件，刚创建时不具有执行权限，所以最大为6
如果umask为022，那么刚创建文件为644,创建目录为755


-------------------------------------------
find命令 后面接的-exec或-ok(以询问的方式执行)
 find . -name "info.txt" -exec ls -l {} \;
 find . -name 'admin.log[0-9][0-9[0-9]' -ok rm {} \;
支持正则?
-------------------------------------------
find 配合xargs
使用xargs时能够批量取得参数以及每一次取得参数的数目都会根据该命令选项和内核中相应的可调参数来确定。
-------------------------------------------
使用grep命令在当前目录所有普通文件中搜索php这个词
find . -name * -type f -print | xargs grep "php"
如果仅显示其文件名
find . -name * -type f -print | xargs echo ""
-------------------------------------------
cron和crontab
crontab格式
分 时 日 月 星期 要运行的命令
crontab [-u username] -e -l -r
-e 编辑crontab文件
-l 列出crontab文件的内容
-r 删除crontab文件
-------------------------------------------

如
30 21 * * * /apps/bin/clear.sh
0,30 18-23 * * * /apps/bin/dbcheck.sh
每天18-23点之间每三十分钟运行一次
-------------------------------------------
提交crontab
创建一个davecron文件 
写入
50,51,52, 18 * * * /bin/echo `date` >/dev/console
使用#注释cron脚本
$ crontab davecron
新建的文件副本会放置在/var/spool/cron目录内，文件名为对应的用户名
-------------------------------------------
at命令
通过 /etc/at.allow和/etc/at.deny限制
at [-f script] [-m -l -r] [time] [date]
其中 -f script 是所要提交的脚本或命令
-m 完成作业后发邮件给用户
-l 列出当前等待运行的作业
-r 清除作业，需提供相应的作业id

#echo find /etc -name "passwd" -print | at now + 1 minute
等同
#at now + 1 minute
at>find /etc -name "passwd" -print
at><EOT>

-------------------------------------------
&
将命令后台运行并把结果输出到文件（标准输出和错误输出）
# command >out.file 2>&1 &
用&提交的命令在帐户退出时进程会结束，如果想要退出帐户之后继续运行，可以使用nohup命令
#nohup command &
-------------------------------------------
用cat在命令行写入文件
#cat > test
输入文字
<CTRL-D>

-------------------------------------------

echo -n 输出不换行
echo -e 转义字符串
-------------------------------------------

read 
取得用户输入并赋值给指定变量
# read name 
# echo $name
如果输入变量比指定的变量数要多（用空格分隔），则剩余字符会被赋值给最后一个变量。
-------------------------------------------
echo "please input a number:\c" && read number && echo $number
-------------------------------------------
cat -v <file_name>可以显示文件的所有控制字符
-------------------------------------------
tee -a 显示并把副本追加到文件末
#echo "hello end" | tee -a log.txt
-------------------------------------------
标准输入 0
标准输出 1
标准错误 2

把标准输出和标准错误一起重定向到file
command 1>file 2>&1
把file1作为标准输入，把标准输出重定向到file2
command <file1 >file2
-------------------------------------------
创建一个长度为0的空文件
$ >myfile

$ sort <name.txt

$ sort <name.txt >name.out

$ mail root < content.txt

-------------------------------------------
sort排序
-------------------------------------------
exec
-------------------------------------------
脚本
#!/bin/env bash
exec 4<&0 0</root/info.txt
read line1
read line2
read line3
exec 0<&4
echo $line1
echo $line2
echo $line3

-------------------------------------------
&& 前一个命令执行成功才执行后一个命令
|| 前一个命令执行失败才执行后一条命令
在当前shell中执行一组命令
(命令1;命令2;...)
使用在子shell而不是当前shell中作为一个整体执行
{命令1;命令2;...}
-------------------------------------------
grep
在输出字符串参数时，最好将其用双引号括起来，调用变量时也应该使用双引号，在调用模式匹配时，应该使用单引号

如 #grep "$MYVAR" 文件名
#grep '^[^48]' data.f 抽出行首不是48的记录
#grep '4\{2,\}' data.f 数字4至少出现两次的所有行
#grep '0\{2,\}' passwd 

-c 只输出匹配行的计数
-i 不区分大小写(只适合单字符)
-h 查询多文件时不显示文件名
-l 仅输出包含匹配字符的文件名
-n 显示匹配行及行号
-s 不显示不存在或无匹配文本的错误信息
-v 显示不包含匹配文本的所有行

-E参数允许使用扩展模式匹配
$grep -E '219|216' data.f
-------------------------------------------

egrep
#cat grepstrings
484
47
#egrep -f grepstrings data.file //按文件提供的模式匹配

#egrep '(abc|xyz)' data.file //查找符号两边或全部
-------------------------------------------



